// this file is auto generated by zookeeper.jute,  Do not edit!

use bytes::{Buf, BufMut, BytesMut};
use crate::errors::ZkError;
use crate::record::{Deserialize, Serialize};

impl Serialize for String {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i32(self.len() as i32);
        buffer.put_slice(self.as_bytes());
        Ok(())
    }

    fn size(&self) -> usize {
        4 + self.len()
    }
}

impl Deserialize for String {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let len = bytes.get_i32();
        if len < 0 {
            return Ok(String::new())
        }
        let mut buf = vec![0; len as usize];
        bytes.copy_to_slice(&mut buf);
        Ok(String::from_utf8(buf).map_err(|_| ZkError::InvalidString)?)
    }
}

impl<T> Serialize for Vec<T> where T: Serialize {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i32(self.len() as i32);
        for it in self {
            it.serialize_into(buffer)?;
        }
        Ok(())
    }

    fn size(&self) -> usize {
        4 + self.iter().map(|it| it.size()).sum::<usize>()
    }
}

impl<T> Deserialize for Vec<T> where T: Deserialize {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let len = bytes.get_i32();
        if len < 0 {
            return Ok(vec![])
        }
        let mut res = Vec::with_capacity(len as usize);
        for _ in 0..len {
            res.push(T::deserialize(bytes)?);
        }
        Ok(res)
    }
}

impl Serialize for Vec<u8> {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i32(self.len() as i32);
        buffer.put_slice(self);
        Ok(())
    }

    fn size(&self) -> usize {
        4 + self.len()
    }
}

impl Deserialize for Vec<u8> {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let len = bytes.get_i32();
        if len < 0 {
            return Ok(vec![])
        }
        let mut buf = vec![0; len as usize];
        bytes.copy_to_slice(&mut buf);
        Ok(buf)
    }
}


#[derive(Debug)]
pub struct Id {
    pub scheme: String,
    pub id: String,
}

impl Serialize for Id {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.scheme.serialize_into(buffer)?;
        self.id.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        self.scheme.size() + self.id.size()
    }
}

impl Deserialize for Id {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let scheme = String::deserialize(bytes)?;
        let id = String::deserialize(bytes)?;
        Ok(Self {
            scheme,
            id,
        })
    }
}

#[derive(Debug)]
pub struct ACL {
    pub perms: i32,
    pub id: Id,
}

impl Serialize for ACL {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i32(self.perms);
        self.id.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        4 + self.id.size()
    }
}

impl Deserialize for ACL {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let perms = bytes.get_i32();
        let id = Id::deserialize(bytes)?;
        Ok(Self {
            perms,
            id,
        })
    }
}

#[derive(Debug)]
pub struct Stat {
    pub czxid: i64,
    pub mzxid: i64,
    pub ctime: i64,
    pub mtime: i64,
    pub version: i32,
    pub cversion: i32,
    pub aversion: i32,
    pub ephemeral_owner: i64,
    pub data_length: i32,
    pub num_children: i32,
    pub pzxid: i64,
}

impl Serialize for Stat {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i64(self.czxid);
        buffer.put_i64(self.mzxid);
        buffer.put_i64(self.ctime);
        buffer.put_i64(self.mtime);
        buffer.put_i32(self.version);
        buffer.put_i32(self.cversion);
        buffer.put_i32(self.aversion);
        buffer.put_i64(self.ephemeral_owner);
        buffer.put_i32(self.data_length);
        buffer.put_i32(self.num_children);
        buffer.put_i64(self.pzxid);
        Ok(())
    }

    fn size(&self) -> usize {
        8 + 8 + 8 + 8 + 4 + 4 + 4 + 8 + 4 + 4 + 8
    }
}

impl Deserialize for Stat {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let czxid = bytes.get_i64();
        let mzxid = bytes.get_i64();
        let ctime = bytes.get_i64();
        let mtime = bytes.get_i64();
        let version = bytes.get_i32();
        let cversion = bytes.get_i32();
        let aversion = bytes.get_i32();
        let ephemeral_owner = bytes.get_i64();
        let data_length = bytes.get_i32();
        let num_children = bytes.get_i32();
        let pzxid = bytes.get_i64();
        Ok(Self {
            czxid,
            mzxid,
            ctime,
            mtime,
            version,
            cversion,
            aversion,
            ephemeral_owner,
            data_length,
            num_children,
            pzxid,
        })
    }
}

#[derive(Debug)]
pub struct StatPersisted {
    pub czxid: i64,
    pub mzxid: i64,
    pub ctime: i64,
    pub mtime: i64,
    pub version: i32,
    pub cversion: i32,
    pub aversion: i32,
    pub ephemeral_owner: i64,
    pub pzxid: i64,
}

impl Serialize for StatPersisted {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i64(self.czxid);
        buffer.put_i64(self.mzxid);
        buffer.put_i64(self.ctime);
        buffer.put_i64(self.mtime);
        buffer.put_i32(self.version);
        buffer.put_i32(self.cversion);
        buffer.put_i32(self.aversion);
        buffer.put_i64(self.ephemeral_owner);
        buffer.put_i64(self.pzxid);
        Ok(())
    }

    fn size(&self) -> usize {
        8 + 8 + 8 + 8 + 4 + 4 + 4 + 8 + 8
    }
}

impl Deserialize for StatPersisted {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let czxid = bytes.get_i64();
        let mzxid = bytes.get_i64();
        let ctime = bytes.get_i64();
        let mtime = bytes.get_i64();
        let version = bytes.get_i32();
        let cversion = bytes.get_i32();
        let aversion = bytes.get_i32();
        let ephemeral_owner = bytes.get_i64();
        let pzxid = bytes.get_i64();
        Ok(Self {
            czxid,
            mzxid,
            ctime,
            mtime,
            version,
            cversion,
            aversion,
            ephemeral_owner,
            pzxid,
        })
    }
}

#[derive(Debug)]
pub struct ClientInfo {
    pub auth_scheme: String,
    pub user: String,
}

impl Serialize for ClientInfo {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.auth_scheme.serialize_into(buffer)?;
        self.user.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        self.auth_scheme.size() + self.user.size()
    }
}

impl Deserialize for ClientInfo {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let auth_scheme = String::deserialize(bytes)?;
        let user = String::deserialize(bytes)?;
        Ok(Self {
            auth_scheme,
            user,
        })
    }
}

#[derive(Debug)]
pub struct ConnectRequest {
    pub protocol_version: i32,
    pub last_zxid_seen: i64,
    pub time_out: i32,
    pub session_id: i64,
    pub passwd: Vec<u8>,
    pub read_only: u8,
}

impl Serialize for ConnectRequest {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i32(self.protocol_version);
        buffer.put_i64(self.last_zxid_seen);
        buffer.put_i32(self.time_out);
        buffer.put_i64(self.session_id);
        self.passwd.serialize_into(buffer)?;
        buffer.put_u8(self.read_only);
        Ok(())
    }

    fn size(&self) -> usize {
        4 + 8 + 4 + 8 + self.passwd.size() + 1
    }
}

impl Deserialize for ConnectRequest {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let protocol_version = bytes.get_i32();
        let last_zxid_seen = bytes.get_i64();
        let time_out = bytes.get_i32();
        let session_id = bytes.get_i64();
        let passwd = Vec::<u8>::deserialize(bytes)?;
        let read_only = if bytes.len() > 1 {
            bytes.get_u8()
        } else {
            0
        };
        Ok(Self {
            protocol_version,
            last_zxid_seen,
            time_out,
            session_id,
            passwd,
            read_only,
        })
    }
}

#[derive(Debug)]
pub struct ConnectResponse {
    pub protocol_version: i32,
    pub time_out: i32,
    pub session_id: i64,
    pub passwd: Vec<u8>,
    pub read_only: u8,
}

impl Serialize for ConnectResponse {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i32(self.protocol_version);
        buffer.put_i32(self.time_out);
        buffer.put_i64(self.session_id);
        self.passwd.serialize_into(buffer)?;
        buffer.put_u8(self.read_only);
        Ok(())
    }

    fn size(&self) -> usize {
        4 + 4 + 8 + self.passwd.size() + 1
    }
}

impl Deserialize for ConnectResponse {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let protocol_version = bytes.get_i32();
        let time_out = bytes.get_i32();
        let session_id = bytes.get_i64();
        let passwd = Vec::<u8>::deserialize(bytes)?;
        let read_only = if bytes.len() > 1 {
            bytes.get_u8()
        } else {
            0
        };
        Ok(Self {
            protocol_version,
            time_out,
            session_id,
            passwd,
            read_only,
        })
    }
}

#[derive(Debug)]
pub struct SetWatches {
    pub relative_zxid: i64,
    pub data_watches: Vec<String>,
    pub exist_watches: Vec<String>,
    pub child_watches: Vec<String>,
}

impl Serialize for SetWatches {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i64(self.relative_zxid);
        self.data_watches.serialize_into(buffer)?;
        self.exist_watches.serialize_into(buffer)?;
        self.child_watches.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        8 + self.data_watches.size() + self.exist_watches.size() + self.child_watches.size()
    }
}

impl Deserialize for SetWatches {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let relative_zxid = bytes.get_i64();
        let data_watches = Vec::<String>::deserialize(bytes)?;
        let exist_watches = Vec::<String>::deserialize(bytes)?;
        let child_watches = Vec::<String>::deserialize(bytes)?;
        Ok(Self {
            relative_zxid,
            data_watches,
            exist_watches,
            child_watches,
        })
    }
}

#[derive(Debug)]
pub struct SetWatches2 {
    pub relative_zxid: i64,
    pub data_watches: Vec<String>,
    pub exist_watches: Vec<String>,
    pub child_watches: Vec<String>,
    pub persistent_watches: Vec<String>,
    pub persistent_recursive_watches: Vec<String>,
}

impl Serialize for SetWatches2 {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i64(self.relative_zxid);
        self.data_watches.serialize_into(buffer)?;
        self.exist_watches.serialize_into(buffer)?;
        self.child_watches.serialize_into(buffer)?;
        self.persistent_watches.serialize_into(buffer)?;
        self.persistent_recursive_watches.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        8 + self.data_watches.size() + self.exist_watches.size() + self.child_watches.size() + self.persistent_watches.size() + self.persistent_recursive_watches.size()
    }
}

impl Deserialize for SetWatches2 {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let relative_zxid = bytes.get_i64();
        let data_watches = Vec::<String>::deserialize(bytes)?;
        let exist_watches = Vec::<String>::deserialize(bytes)?;
        let child_watches = Vec::<String>::deserialize(bytes)?;
        let persistent_watches = Vec::<String>::deserialize(bytes)?;
        let persistent_recursive_watches = Vec::<String>::deserialize(bytes)?;
        Ok(Self {
            relative_zxid,
            data_watches,
            exist_watches,
            child_watches,
            persistent_watches,
            persistent_recursive_watches,
        })
    }
}

#[derive(Debug)]
pub struct RequestHeader {
    pub xid: i32,
    pub r#type: i32,
}

impl Serialize for RequestHeader {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i32(self.xid);
        buffer.put_i32(self.r#type);
        Ok(())
    }

    fn size(&self) -> usize {
        4 + 4
    }
}

impl Deserialize for RequestHeader {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let xid = bytes.get_i32();
        let r#type = bytes.get_i32();
        Ok(Self {
            xid,
            r#type,
        })
    }
}

#[derive(Debug)]
pub struct MultiHeader {
    pub r#type: i32,
    pub done: u8,
    pub err: i32,
}

impl Serialize for MultiHeader {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i32(self.r#type);
        buffer.put_u8(self.done);
        buffer.put_i32(self.err);
        Ok(())
    }

    fn size(&self) -> usize {
        4 + 1 + 4
    }
}

impl Deserialize for MultiHeader {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let r#type = bytes.get_i32();
        let done = bytes.get_u8();
        let err = bytes.get_i32();
        Ok(Self {
            r#type,
            done,
            err,
        })
    }
}

#[derive(Debug)]
pub struct AuthPacket {
    pub r#type: i32,
    pub scheme: String,
    pub auth: Vec<u8>,
}

impl Serialize for AuthPacket {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i32(self.r#type);
        self.scheme.serialize_into(buffer)?;
        self.auth.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        4 + self.scheme.size() + self.auth.size()
    }
}

impl Deserialize for AuthPacket {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let r#type = bytes.get_i32();
        let scheme = String::deserialize(bytes)?;
        let auth = Vec::<u8>::deserialize(bytes)?;
        Ok(Self {
            r#type,
            scheme,
            auth,
        })
    }
}

#[derive(Debug)]
pub struct ReplyHeader {
    pub xid: i32,
    pub zxid: i64,
    pub err: i32,
}

impl Serialize for ReplyHeader {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i32(self.xid);
        buffer.put_i64(self.zxid);
        buffer.put_i32(self.err);
        Ok(())
    }

    fn size(&self) -> usize {
        4 + 8 + 4
    }
}

impl Deserialize for ReplyHeader {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let xid = bytes.get_i32();
        let zxid = bytes.get_i64();
        let err = bytes.get_i32();
        Ok(Self {
            xid,
            zxid,
            err,
        })
    }
}

#[derive(Debug)]
pub struct GetDataRequest {
    pub path: String,
    pub watch: u8,
}

impl Serialize for GetDataRequest {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        buffer.put_u8(self.watch);
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size() + 1
    }
}

impl Deserialize for GetDataRequest {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        let watch = bytes.get_u8();
        Ok(Self {
            path,
            watch,
        })
    }
}

#[derive(Debug)]
pub struct SetDataRequest {
    pub path: String,
    pub data: Vec<u8>,
    pub version: i32,
}

impl Serialize for SetDataRequest {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        self.data.serialize_into(buffer)?;
        buffer.put_i32(self.version);
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size() + self.data.size() + 4
    }
}

impl Deserialize for SetDataRequest {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        let data = Vec::<u8>::deserialize(bytes)?;
        let version = bytes.get_i32();
        Ok(Self {
            path,
            data,
            version,
        })
    }
}

#[derive(Debug)]
pub struct ReconfigRequest {
    pub joining_servers: String,
    pub leaving_servers: String,
    pub new_members: String,
    pub cur_config_id: i64,
}

impl Serialize for ReconfigRequest {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.joining_servers.serialize_into(buffer)?;
        self.leaving_servers.serialize_into(buffer)?;
        self.new_members.serialize_into(buffer)?;
        buffer.put_i64(self.cur_config_id);
        Ok(())
    }

    fn size(&self) -> usize {
        self.joining_servers.size() + self.leaving_servers.size() + self.new_members.size() + 8
    }
}

impl Deserialize for ReconfigRequest {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let joining_servers = String::deserialize(bytes)?;
        let leaving_servers = String::deserialize(bytes)?;
        let new_members = String::deserialize(bytes)?;
        let cur_config_id = bytes.get_i64();
        Ok(Self {
            joining_servers,
            leaving_servers,
            new_members,
            cur_config_id,
        })
    }
}

#[derive(Debug)]
pub struct SetDataResponse {
    pub stat: Stat,
}

impl Serialize for SetDataResponse {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.stat.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        self.stat.size()
    }
}

impl Deserialize for SetDataResponse {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let stat = Stat::deserialize(bytes)?;
        Ok(Self {
            stat,
        })
    }
}

#[derive(Debug)]
pub struct GetSASLRequest {
    pub token: Vec<u8>,
}

impl Serialize for GetSASLRequest {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.token.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        self.token.size()
    }
}

impl Deserialize for GetSASLRequest {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let token = Vec::<u8>::deserialize(bytes)?;
        Ok(Self {
            token,
        })
    }
}

#[derive(Debug)]
pub struct SetSASLRequest {
    pub token: Vec<u8>,
}

impl Serialize for SetSASLRequest {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.token.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        self.token.size()
    }
}

impl Deserialize for SetSASLRequest {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let token = Vec::<u8>::deserialize(bytes)?;
        Ok(Self {
            token,
        })
    }
}

#[derive(Debug)]
pub struct SetSASLResponse {
    pub token: Vec<u8>,
}

impl Serialize for SetSASLResponse {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.token.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        self.token.size()
    }
}

impl Deserialize for SetSASLResponse {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let token = Vec::<u8>::deserialize(bytes)?;
        Ok(Self {
            token,
        })
    }
}

#[derive(Debug)]
pub struct CreateRequest {
    pub path: String,
    pub data: Vec<u8>,
    pub acl: Vec<ACL>,
    pub flags: i32,
}

impl Serialize for CreateRequest {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        self.data.serialize_into(buffer)?;
        buffer.put_i32(self.acl.len() as i32);
        for it in &self.acl {
            it.serialize_into(buffer)?;
        }
        buffer.put_i32(self.flags);
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size() + self.data.size() + self.acl.size() + 4
    }
}

impl Deserialize for CreateRequest {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        let data = Vec::<u8>::deserialize(bytes)?;
        let acl = Vec::<ACL>::deserialize(bytes)?;
        let flags = bytes.get_i32();
        Ok(Self {
            path,
            data,
            acl,
            flags,
        })
    }
}

#[derive(Debug)]
pub struct CreateTTLRequest {
    pub path: String,
    pub data: Vec<u8>,
    pub acl: Vec<ACL>,
    pub flags: i32,
    pub ttl: i64,
}

impl Serialize for CreateTTLRequest {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        self.data.serialize_into(buffer)?;
        buffer.put_i32(self.acl.len() as i32);
        for it in &self.acl {
            it.serialize_into(buffer)?;
        }
        buffer.put_i32(self.flags);
        buffer.put_i64(self.ttl);
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size() + self.data.size() + self.acl.size() + 4 + 8
    }
}

impl Deserialize for CreateTTLRequest {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        let data = Vec::<u8>::deserialize(bytes)?;
        let acl = Vec::<ACL>::deserialize(bytes)?;
        let flags = bytes.get_i32();
        let ttl = bytes.get_i64();
        Ok(Self {
            path,
            data,
            acl,
            flags,
            ttl,
        })
    }
}

#[derive(Debug)]
pub struct DeleteRequest {
    pub path: String,
    pub version: i32,
}

impl Serialize for DeleteRequest {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        buffer.put_i32(self.version);
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size() + 4
    }
}

impl Deserialize for DeleteRequest {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        let version = bytes.get_i32();
        Ok(Self {
            path,
            version,
        })
    }
}

#[derive(Debug)]
pub struct GetChildrenRequest {
    pub path: String,
    pub watch: u8,
}

impl Serialize for GetChildrenRequest {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        buffer.put_u8(self.watch);
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size() + 1
    }
}

impl Deserialize for GetChildrenRequest {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        let watch = bytes.get_u8();
        Ok(Self {
            path,
            watch,
        })
    }
}

#[derive(Debug)]
pub struct GetAllChildrenNumberRequest {
    pub path: String,
}

impl Serialize for GetAllChildrenNumberRequest {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size()
    }
}

impl Deserialize for GetAllChildrenNumberRequest {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        Ok(Self {
            path,
        })
    }
}

#[derive(Debug)]
pub struct GetChildren2Request {
    pub path: String,
    pub watch: u8,
}

impl Serialize for GetChildren2Request {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        buffer.put_u8(self.watch);
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size() + 1
    }
}

impl Deserialize for GetChildren2Request {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        let watch = bytes.get_u8();
        Ok(Self {
            path,
            watch,
        })
    }
}

#[derive(Debug)]
pub struct CheckVersionRequest {
    pub path: String,
    pub version: i32,
}

impl Serialize for CheckVersionRequest {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        buffer.put_i32(self.version);
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size() + 4
    }
}

impl Deserialize for CheckVersionRequest {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        let version = bytes.get_i32();
        Ok(Self {
            path,
            version,
        })
    }
}

#[derive(Debug)]
pub struct GetMaxChildrenRequest {
    pub path: String,
}

impl Serialize for GetMaxChildrenRequest {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size()
    }
}

impl Deserialize for GetMaxChildrenRequest {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        Ok(Self {
            path,
        })
    }
}

#[derive(Debug)]
pub struct GetMaxChildrenResponse {
    pub max: i32,
}

impl Serialize for GetMaxChildrenResponse {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i32(self.max);
        Ok(())
    }

    fn size(&self) -> usize {
        4
    }
}

impl Deserialize for GetMaxChildrenResponse {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let max = bytes.get_i32();
        Ok(Self {
            max,
        })
    }
}

#[derive(Debug)]
pub struct SetMaxChildrenRequest {
    pub path: String,
    pub max: i32,
}

impl Serialize for SetMaxChildrenRequest {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        buffer.put_i32(self.max);
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size() + 4
    }
}

impl Deserialize for SetMaxChildrenRequest {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        let max = bytes.get_i32();
        Ok(Self {
            path,
            max,
        })
    }
}

#[derive(Debug)]
pub struct SyncRequest {
    pub path: String,
}

impl Serialize for SyncRequest {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size()
    }
}

impl Deserialize for SyncRequest {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        Ok(Self {
            path,
        })
    }
}

#[derive(Debug)]
pub struct SyncResponse {
    pub path: String,
}

impl Serialize for SyncResponse {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size()
    }
}

impl Deserialize for SyncResponse {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        Ok(Self {
            path,
        })
    }
}

#[derive(Debug)]
pub struct GetACLRequest {
    pub path: String,
}

impl Serialize for GetACLRequest {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size()
    }
}

impl Deserialize for GetACLRequest {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        Ok(Self {
            path,
        })
    }
}

#[derive(Debug)]
pub struct SetACLRequest {
    pub path: String,
    pub acl: Vec<ACL>,
    pub version: i32,
}

impl Serialize for SetACLRequest {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        buffer.put_i32(self.acl.len() as i32);
        for it in &self.acl {
            it.serialize_into(buffer)?;
        }
        buffer.put_i32(self.version);
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size() + self.acl.size() + 4
    }
}

impl Deserialize for SetACLRequest {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        let acl = Vec::<ACL>::deserialize(bytes)?;
        let version = bytes.get_i32();
        Ok(Self {
            path,
            acl,
            version,
        })
    }
}

#[derive(Debug)]
pub struct SetACLResponse {
    pub stat: Stat,
}

impl Serialize for SetACLResponse {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.stat.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        self.stat.size()
    }
}

impl Deserialize for SetACLResponse {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let stat = Stat::deserialize(bytes)?;
        Ok(Self {
            stat,
        })
    }
}

#[derive(Debug)]
pub struct AddWatchRequest {
    pub path: String,
    pub mode: i32,
}

impl Serialize for AddWatchRequest {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        buffer.put_i32(self.mode);
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size() + 4
    }
}

impl Deserialize for AddWatchRequest {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        let mode = bytes.get_i32();
        Ok(Self {
            path,
            mode,
        })
    }
}

#[derive(Debug)]
pub struct WatcherEvent {
    pub r#type: i32,
    pub state: i32,
    pub path: String,
}

impl Serialize for WatcherEvent {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i32(self.r#type);
        buffer.put_i32(self.state);
        self.path.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        4 + 4 + self.path.size()
    }
}

impl Deserialize for WatcherEvent {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let r#type = bytes.get_i32();
        let state = bytes.get_i32();
        let path = String::deserialize(bytes)?;
        Ok(Self {
            r#type,
            state,
            path,
        })
    }
}

#[derive(Debug)]
pub struct ErrorResponse {
    pub err: i32,
}

impl Serialize for ErrorResponse {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i32(self.err);
        Ok(())
    }

    fn size(&self) -> usize {
        4
    }
}

impl Deserialize for ErrorResponse {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let err = bytes.get_i32();
        Ok(Self {
            err,
        })
    }
}

#[derive(Debug)]
pub struct CreateResponse {
    pub path: String,
}

impl Serialize for CreateResponse {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size()
    }
}

impl Deserialize for CreateResponse {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        Ok(Self {
            path,
        })
    }
}

#[derive(Debug)]
pub struct Create2Response {
    pub path: String,
    pub stat: Stat,
}

impl Serialize for Create2Response {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        self.stat.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size() + self.stat.size()
    }
}

impl Deserialize for Create2Response {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        let stat = Stat::deserialize(bytes)?;
        Ok(Self {
            path,
            stat,
        })
    }
}

#[derive(Debug)]
pub struct ExistsRequest {
    pub path: String,
    pub watch: u8,
}

impl Serialize for ExistsRequest {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        buffer.put_u8(self.watch);
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size() + 1
    }
}

impl Deserialize for ExistsRequest {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        let watch = bytes.get_u8();
        Ok(Self {
            path,
            watch,
        })
    }
}

#[derive(Debug)]
pub struct ExistsResponse {
    pub stat: Stat,
}

impl Serialize for ExistsResponse {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.stat.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        self.stat.size()
    }
}

impl Deserialize for ExistsResponse {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let stat = Stat::deserialize(bytes)?;
        Ok(Self {
            stat,
        })
    }
}

#[derive(Debug)]
pub struct GetDataResponse {
    pub data: Vec<u8>,
    pub stat: Stat,
}

impl Serialize for GetDataResponse {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.data.serialize_into(buffer)?;
        self.stat.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        self.data.size() + self.stat.size()
    }
}

impl Deserialize for GetDataResponse {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let data = Vec::<u8>::deserialize(bytes)?;
        let stat = Stat::deserialize(bytes)?;
        Ok(Self {
            data,
            stat,
        })
    }
}

#[derive(Debug)]
pub struct GetChildrenResponse {
    pub children: Vec<String>,
}

impl Serialize for GetChildrenResponse {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.children.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        self.children.size()
    }
}

impl Deserialize for GetChildrenResponse {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let children = Vec::<String>::deserialize(bytes)?;
        Ok(Self {
            children,
        })
    }
}

#[derive(Debug)]
pub struct GetAllChildrenNumberResponse {
    pub total_number: i32,
}

impl Serialize for GetAllChildrenNumberResponse {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i32(self.total_number);
        Ok(())
    }

    fn size(&self) -> usize {
        4
    }
}

impl Deserialize for GetAllChildrenNumberResponse {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let total_number = bytes.get_i32();
        Ok(Self {
            total_number,
        })
    }
}

#[derive(Debug)]
pub struct GetChildren2Response {
    pub children: Vec<String>,
    pub stat: Stat,
}

impl Serialize for GetChildren2Response {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.children.serialize_into(buffer)?;
        self.stat.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        self.children.size() + self.stat.size()
    }
}

impl Deserialize for GetChildren2Response {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let children = Vec::<String>::deserialize(bytes)?;
        let stat = Stat::deserialize(bytes)?;
        Ok(Self {
            children,
            stat,
        })
    }
}

#[derive(Debug)]
pub struct GetACLResponse {
    pub acl: Vec<ACL>,
    pub stat: Stat,
}

impl Serialize for GetACLResponse {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i32(self.acl.len() as i32);
        for it in &self.acl {
            it.serialize_into(buffer)?;
        }
        self.stat.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        self.acl.size() + self.stat.size()
    }
}

impl Deserialize for GetACLResponse {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let acl = Vec::<ACL>::deserialize(bytes)?;
        let stat = Stat::deserialize(bytes)?;
        Ok(Self {
            acl,
            stat,
        })
    }
}

#[derive(Debug)]
pub struct CheckWatchesRequest {
    pub path: String,
    pub r#type: i32,
}

impl Serialize for CheckWatchesRequest {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        buffer.put_i32(self.r#type);
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size() + 4
    }
}

impl Deserialize for CheckWatchesRequest {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        let r#type = bytes.get_i32();
        Ok(Self {
            path,
            r#type,
        })
    }
}

#[derive(Debug)]
pub struct RemoveWatchesRequest {
    pub path: String,
    pub r#type: i32,
}

impl Serialize for RemoveWatchesRequest {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        buffer.put_i32(self.r#type);
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size() + 4
    }
}

impl Deserialize for RemoveWatchesRequest {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        let r#type = bytes.get_i32();
        Ok(Self {
            path,
            r#type,
        })
    }
}

#[derive(Debug)]
pub struct GetEphemeralsRequest {
    pub prefix_path: String,
}

impl Serialize for GetEphemeralsRequest {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.prefix_path.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        self.prefix_path.size()
    }
}

impl Deserialize for GetEphemeralsRequest {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let prefix_path = String::deserialize(bytes)?;
        Ok(Self {
            prefix_path,
        })
    }
}

#[derive(Debug)]
pub struct GetEphemeralsResponse {
    pub ephemerals: Vec<String>,
}

impl Serialize for GetEphemeralsResponse {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.ephemerals.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        self.ephemerals.size()
    }
}

impl Deserialize for GetEphemeralsResponse {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let ephemerals = Vec::<String>::deserialize(bytes)?;
        Ok(Self {
            ephemerals,
        })
    }
}

#[derive(Debug)]
pub struct WhoAmIResponse {
    pub client_info: Vec<ClientInfo>,
}

impl Serialize for WhoAmIResponse {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i32(self.client_info.len() as i32);
        for it in &self.client_info {
            it.serialize_into(buffer)?;
        }
        Ok(())
    }

    fn size(&self) -> usize {
        self.client_info.size()
    }
}

impl Deserialize for WhoAmIResponse {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let client_info = Vec::<ClientInfo>::deserialize(bytes)?;
        Ok(Self {
            client_info,
        })
    }
}

#[derive(Debug)]
pub struct LearnerInfo {
    pub serverid: i64,
    pub protocol_version: i32,
    pub config_version: i64,
}

impl Serialize for LearnerInfo {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i64(self.serverid);
        buffer.put_i32(self.protocol_version);
        buffer.put_i64(self.config_version);
        Ok(())
    }

    fn size(&self) -> usize {
        8 + 4 + 8
    }
}

impl Deserialize for LearnerInfo {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let serverid = bytes.get_i64();
        let protocol_version = bytes.get_i32();
        let config_version = bytes.get_i64();
        Ok(Self {
            serverid,
            protocol_version,
            config_version,
        })
    }
}

#[derive(Debug)]
pub struct QuorumPacket {
    pub r#type: i32,
    pub zxid: i64,
    pub data: Vec<u8>,
    pub authinfo: Vec<Id>,
}

impl Serialize for QuorumPacket {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i32(self.r#type);
        buffer.put_i64(self.zxid);
        self.data.serialize_into(buffer)?;
        buffer.put_i32(self.authinfo.len() as i32);
        for it in &self.authinfo {
            it.serialize_into(buffer)?;
        }
        Ok(())
    }

    fn size(&self) -> usize {
        4 + 8 + self.data.size() + self.authinfo.size()
    }
}

impl Deserialize for QuorumPacket {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let r#type = bytes.get_i32();
        let zxid = bytes.get_i64();
        let data = Vec::<u8>::deserialize(bytes)?;
        let authinfo = Vec::<Id>::deserialize(bytes)?;
        Ok(Self {
            r#type,
            zxid,
            data,
            authinfo,
        })
    }
}

#[derive(Debug)]
pub struct QuorumAuthPacket {
    pub magic: i64,
    pub status: i32,
    pub token: Vec<u8>,
}

impl Serialize for QuorumAuthPacket {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i64(self.magic);
        buffer.put_i32(self.status);
        self.token.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        8 + 4 + self.token.size()
    }
}

impl Deserialize for QuorumAuthPacket {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let magic = bytes.get_i64();
        let status = bytes.get_i32();
        let token = Vec::<u8>::deserialize(bytes)?;
        Ok(Self {
            magic,
            status,
            token,
        })
    }
}

#[derive(Debug)]
pub struct FileHeader {
    pub magic: i32,
    pub version: i32,
    pub dbid: i64,
}

impl Serialize for FileHeader {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i32(self.magic);
        buffer.put_i32(self.version);
        buffer.put_i64(self.dbid);
        Ok(())
    }

    fn size(&self) -> usize {
        4 + 4 + 8
    }
}

impl Deserialize for FileHeader {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let magic = bytes.get_i32();
        let version = bytes.get_i32();
        let dbid = bytes.get_i64();
        Ok(Self {
            magic,
            version,
            dbid,
        })
    }
}

#[derive(Debug)]
pub struct TxnDigest {
    pub version: i32,
    pub tree_digest: i64,
}

impl Serialize for TxnDigest {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i32(self.version);
        buffer.put_i64(self.tree_digest);
        Ok(())
    }

    fn size(&self) -> usize {
        4 + 8
    }
}

impl Deserialize for TxnDigest {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let version = bytes.get_i32();
        let tree_digest = bytes.get_i64();
        Ok(Self {
            version,
            tree_digest,
        })
    }
}

#[derive(Debug)]
pub struct TxnHeader {
    pub client_id: i64,
    pub cxid: i32,
    pub zxid: i64,
    pub time: i64,
    pub r#type: i32,
}

impl Serialize for TxnHeader {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i64(self.client_id);
        buffer.put_i32(self.cxid);
        buffer.put_i64(self.zxid);
        buffer.put_i64(self.time);
        buffer.put_i32(self.r#type);
        Ok(())
    }

    fn size(&self) -> usize {
        8 + 4 + 8 + 8 + 4
    }
}

impl Deserialize for TxnHeader {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let client_id = bytes.get_i64();
        let cxid = bytes.get_i32();
        let zxid = bytes.get_i64();
        let time = bytes.get_i64();
        let r#type = bytes.get_i32();
        Ok(Self {
            client_id,
            cxid,
            zxid,
            time,
            r#type,
        })
    }
}

#[derive(Debug)]
pub struct CreateTxnV0 {
    pub path: String,
    pub data: Vec<u8>,
    pub acl: Vec<ACL>,
    pub ephemeral: u8,
}

impl Serialize for CreateTxnV0 {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        self.data.serialize_into(buffer)?;
        buffer.put_i32(self.acl.len() as i32);
        for it in &self.acl {
            it.serialize_into(buffer)?;
        }
        buffer.put_u8(self.ephemeral);
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size() + self.data.size() + self.acl.size() + 1
    }
}

impl Deserialize for CreateTxnV0 {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        let data = Vec::<u8>::deserialize(bytes)?;
        let acl = Vec::<ACL>::deserialize(bytes)?;
        let ephemeral = bytes.get_u8();
        Ok(Self {
            path,
            data,
            acl,
            ephemeral,
        })
    }
}

#[derive(Debug)]
pub struct CreateTxn {
    pub path: String,
    pub data: Vec<u8>,
    pub acl: Vec<ACL>,
    pub ephemeral: u8,
    pub parent_c_version: i32,
}

impl Serialize for CreateTxn {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        self.data.serialize_into(buffer)?;
        buffer.put_i32(self.acl.len() as i32);
        for it in &self.acl {
            it.serialize_into(buffer)?;
        }
        buffer.put_u8(self.ephemeral);
        buffer.put_i32(self.parent_c_version);
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size() + self.data.size() + self.acl.size() + 1 + 4
    }
}

impl Deserialize for CreateTxn {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        let data = Vec::<u8>::deserialize(bytes)?;
        let acl = Vec::<ACL>::deserialize(bytes)?;
        let ephemeral = bytes.get_u8();
        let parent_c_version = bytes.get_i32();
        Ok(Self {
            path,
            data,
            acl,
            ephemeral,
            parent_c_version,
        })
    }
}

#[derive(Debug)]
pub struct CreateTTLTxn {
    pub path: String,
    pub data: Vec<u8>,
    pub acl: Vec<ACL>,
    pub parent_c_version: i32,
    pub ttl: i64,
}

impl Serialize for CreateTTLTxn {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        self.data.serialize_into(buffer)?;
        buffer.put_i32(self.acl.len() as i32);
        for it in &self.acl {
            it.serialize_into(buffer)?;
        }
        buffer.put_i32(self.parent_c_version);
        buffer.put_i64(self.ttl);
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size() + self.data.size() + self.acl.size() + 4 + 8
    }
}

impl Deserialize for CreateTTLTxn {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        let data = Vec::<u8>::deserialize(bytes)?;
        let acl = Vec::<ACL>::deserialize(bytes)?;
        let parent_c_version = bytes.get_i32();
        let ttl = bytes.get_i64();
        Ok(Self {
            path,
            data,
            acl,
            parent_c_version,
            ttl,
        })
    }
}

#[derive(Debug)]
pub struct CreateContainerTxn {
    pub path: String,
    pub data: Vec<u8>,
    pub acl: Vec<ACL>,
    pub parent_c_version: i32,
}

impl Serialize for CreateContainerTxn {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        self.data.serialize_into(buffer)?;
        buffer.put_i32(self.acl.len() as i32);
        for it in &self.acl {
            it.serialize_into(buffer)?;
        }
        buffer.put_i32(self.parent_c_version);
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size() + self.data.size() + self.acl.size() + 4
    }
}

impl Deserialize for CreateContainerTxn {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        let data = Vec::<u8>::deserialize(bytes)?;
        let acl = Vec::<ACL>::deserialize(bytes)?;
        let parent_c_version = bytes.get_i32();
        Ok(Self {
            path,
            data,
            acl,
            parent_c_version,
        })
    }
}

#[derive(Debug)]
pub struct DeleteTxn {
    pub path: String,
}

impl Serialize for DeleteTxn {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size()
    }
}

impl Deserialize for DeleteTxn {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        Ok(Self {
            path,
        })
    }
}

#[derive(Debug)]
pub struct SetDataTxn {
    pub path: String,
    pub data: Vec<u8>,
    pub version: i32,
}

impl Serialize for SetDataTxn {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        self.data.serialize_into(buffer)?;
        buffer.put_i32(self.version);
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size() + self.data.size() + 4
    }
}

impl Deserialize for SetDataTxn {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        let data = Vec::<u8>::deserialize(bytes)?;
        let version = bytes.get_i32();
        Ok(Self {
            path,
            data,
            version,
        })
    }
}

#[derive(Debug)]
pub struct CheckVersionTxn {
    pub path: String,
    pub version: i32,
}

impl Serialize for CheckVersionTxn {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        buffer.put_i32(self.version);
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size() + 4
    }
}

impl Deserialize for CheckVersionTxn {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        let version = bytes.get_i32();
        Ok(Self {
            path,
            version,
        })
    }
}

#[derive(Debug)]
pub struct SetACLTxn {
    pub path: String,
    pub acl: Vec<ACL>,
    pub version: i32,
}

impl Serialize for SetACLTxn {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        buffer.put_i32(self.acl.len() as i32);
        for it in &self.acl {
            it.serialize_into(buffer)?;
        }
        buffer.put_i32(self.version);
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size() + self.acl.size() + 4
    }
}

impl Deserialize for SetACLTxn {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        let acl = Vec::<ACL>::deserialize(bytes)?;
        let version = bytes.get_i32();
        Ok(Self {
            path,
            acl,
            version,
        })
    }
}

#[derive(Debug)]
pub struct SetMaxChildrenTxn {
    pub path: String,
    pub max: i32,
}

impl Serialize for SetMaxChildrenTxn {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.path.serialize_into(buffer)?;
        buffer.put_i32(self.max);
        Ok(())
    }

    fn size(&self) -> usize {
        self.path.size() + 4
    }
}

impl Deserialize for SetMaxChildrenTxn {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let path = String::deserialize(bytes)?;
        let max = bytes.get_i32();
        Ok(Self {
            path,
            max,
        })
    }
}

#[derive(Debug)]
pub struct CreateSessionTxn {
    pub time_out: i32,
}

impl Serialize for CreateSessionTxn {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i32(self.time_out);
        Ok(())
    }

    fn size(&self) -> usize {
        4
    }
}

impl Deserialize for CreateSessionTxn {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let time_out = bytes.get_i32();
        Ok(Self {
            time_out,
        })
    }
}

#[derive(Debug)]
pub struct CloseSessionTxn {
    pub paths2_delete: Vec<String>,
}

impl Serialize for CloseSessionTxn {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        self.paths2_delete.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        self.paths2_delete.size()
    }
}

impl Deserialize for CloseSessionTxn {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let paths2_delete = Vec::<String>::deserialize(bytes)?;
        Ok(Self {
            paths2_delete,
        })
    }
}

#[derive(Debug)]
pub struct ErrorTxn {
    pub err: i32,
}

impl Serialize for ErrorTxn {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i32(self.err);
        Ok(())
    }

    fn size(&self) -> usize {
        4
    }
}

impl Deserialize for ErrorTxn {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let err = bytes.get_i32();
        Ok(Self {
            err,
        })
    }
}

#[derive(Debug)]
pub struct Txn {
    pub r#type: i32,
    pub data: Vec<u8>,
}

impl Serialize for Txn {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i32(self.r#type);
        self.data.serialize_into(buffer)?;
        Ok(())
    }

    fn size(&self) -> usize {
        4 + self.data.size()
    }
}

impl Deserialize for Txn {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let r#type = bytes.get_i32();
        let data = Vec::<u8>::deserialize(bytes)?;
        Ok(Self {
            r#type,
            data,
        })
    }
}

#[derive(Debug)]
pub struct MultiTxn {
    pub txns: Vec<Txn>,
}

impl Serialize for MultiTxn {
    fn serialize_into(&self, buffer: &mut BytesMut) -> Result<(), ZkError> {
        buffer.put_i32(self.txns.len() as i32);
        for it in &self.txns {
            it.serialize_into(buffer)?;
        }
        Ok(())
    }

    fn size(&self) -> usize {
        self.txns.size()
    }
}

impl Deserialize for MultiTxn {
    fn deserialize(bytes: &mut BytesMut) -> Result<Self, ZkError> {
        let txns = Vec::<Txn>::deserialize(bytes)?;
        Ok(Self {
            txns,
        })
    }
}
